---
import ImageItem from './ImageItem.astro';
import { distributeByAspectRatio } from '../lib/masonry';
import type { Artwork } from '../lib/artworks';

interface Props {
	artworks: Artwork[];
	breakpointCols?: Record<number | 'default', number>;
	class?: string;
	columnClass?: string;
	eagerCount?: number;
}

const {
	artworks,
	breakpointCols = { default: 4, 1280: 3, 900: 2, 640: 1 },
	class: className = 'static-masonry-grid',
	columnClass = 'static-masonry-column',
	eagerCount = 10,
} = Astro.props;

// Get unique column counts
const columnCounts = new Set(Object.values(breakpointCols));

// Pre-distribute artworks for each column count
const distributions = new Map<number, Artwork[][]>();
columnCounts.forEach((count) => {
	distributions.set(count, distributeByAspectRatio(artworks, count));
});
---

<!-- Container where the active layout will be inserted -->
<div id="masonry-container" class="mx-auto"></div>

<!-- Templates for each layout - these don't render or load images -->
{
	Array.from(columnCounts).map((columnCount) => {
		const columns = distributions.get(columnCount)!;
		return (
			<template data-layout={columnCount}>
				<div class={`${className} layout-${columnCount}`} data-columns={columnCount}>
					{columns.map((column) => (
						<div class={columnClass}>
							{column.map((artwork) => {
								const index = artworks.indexOf(artwork);
								return <ImageItem artwork={artwork} lazy={index >= eagerCount} />;
							})}
						</div>
					))}
				</div>
			</template>
		);
	})
}

<style>
	.static-masonry-grid {
		width: 100%;
		display: flex;
		margin-left: -1rem;
	}

	.static-masonry-column {
		flex: 1;
		display: flex;
		flex-direction: column;
		gap: 1rem;
		padding-left: 1rem;
	}
</style>

<script define:vars={{ breakpointCols }}>
	let imageObserver = null;

	// Function to initialize intersection observer for lazy loading
	function initLazyLoading() {
		// Disconnect existing observer if any
		if (imageObserver) {
			imageObserver.disconnect();
		}

		// Create new observer
		if ('IntersectionObserver' in window) {
			imageObserver = new IntersectionObserver(
				(entries, observer) => {
					entries.forEach((entry) => {
						if (entry.isIntersecting) {
							const img = entry.target;
							const src = img.getAttribute('data-src');
							const srcset = img.getAttribute('data-srcset');
							const sizes = img.getAttribute('data-sizes');

							if (src) {
								img.src = src;
								if (srcset) img.srcset = srcset;
								if (sizes) img.sizes = sizes;

								img.onload = () => {
									// Remove skeleton and min-height constraint
									const skeleton = img.previousElementSibling;
									if (skeleton) skeleton.remove();

									const wrapper = img.parentElement;
									if (wrapper && wrapper.classList.contains('min-h-[300px]')) {
										wrapper.classList.remove('min-h-[300px]');
									}

									img.classList.remove('opacity-0');
									img.classList.add('opacity-100');
								};

								observer.unobserve(img);
							}
						}
					});
				},
				{
					rootMargin: '200px 0px',
					threshold: 0.01,
				}
			);

			// Observe all lazy images
			document.querySelectorAll('.lazy-image').forEach((img) => {
				imageObserver.observe(img);
			});
		} else {
			// Fallback for browsers without IntersectionObserver
			document.querySelectorAll('.lazy-image').forEach((img) => {
				const element = img;
				const src = element.getAttribute('data-src');
				const srcset = element.getAttribute('data-srcset');
				const sizes = element.getAttribute('data-sizes');

				if (src) element.src = src;
				if (srcset) element.srcset = srcset;
				if (sizes) element.sizes = sizes;

				const skeleton = element.previousElementSibling;
				if (skeleton) skeleton.remove();
				element.classList.remove('opacity-0');
				element.classList.add('opacity-100');
			});
		}
	}

	// Function to determine which layout to show based on viewport
	function getLayoutForViewport() {
		const width = window.innerWidth;
		
		if (width <= 640) return breakpointCols[640] || 1;
		if (width <= 900) return breakpointCols[900] || 2;
		if (width <= 1280) return breakpointCols[1280] || 3;
		return breakpointCols.default || 4;
	}

	// Function to render the appropriate layout
	function renderLayout() {
		const columnCount = getLayoutForViewport();
		const template = document.querySelector(`template[data-layout="${columnCount}"]`);
		const container = document.getElementById('masonry-container');
		
		if (!template || !container) return;
		
		// Clear existing content
		container.innerHTML = '';
		
		// Clone and insert the template content
		const content = template.content.cloneNode(true);
		container.appendChild(content);

		// Reinitialize lazy loading for new content
		initLazyLoading();
	}

	// Render on load
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', renderLayout);
	} else {
		renderLayout();
	}

	// Re-render on resize (debounced)
	let resizeTimeout;
	window.addEventListener('resize', () => {
		clearTimeout(resizeTimeout);
		resizeTimeout = setTimeout(renderLayout, 200);
	});
</script>
