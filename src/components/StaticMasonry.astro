---
import ImageItem from './ImageItem.astro';
import { distributeByAspectRatio } from '../lib/masonry';
import type { Artwork } from '../lib/artworks';

interface Props {
	artworks: Artwork[];
	breakpointCols?: Record<number | 'default', number>;
	class?: string;
	columnClass?: string;
	eagerCount?: number;
}

const {
	artworks,
	breakpointCols = { default: 4, 1280: 3, 900: 2, 640: 1 },
	class: className = 'static-masonry-grid',
	columnClass = 'static-masonry-column',
	eagerCount = 10,
} = Astro.props;

// Get unique column counts
const columnCounts = new Set(Object.values(breakpointCols));

// Pre-distribute artworks for each column count
const distributions = new Map<number, Artwork[][]>();
columnCounts.forEach((count) => {
	distributions.set(count, distributeByAspectRatio(artworks, count));
});
---

<!-- Container where the active layout will be inserted -->
<div id="masonry-container" class="mx-auto"></div>

<!-- Templates for each layout - these don't render or load images -->
{
	Array.from(columnCounts).map((columnCount) => {
		const columns = distributions.get(columnCount)!;
		return (
			<template data-layout={columnCount}>
				<div
					class={`${className} layout-${columnCount}`}
					data-columns={columnCount}
				>
					{columns.map((column) => (
						<div class={columnClass}>
							{column.map((artwork) => {
								const index = artworks.indexOf(artwork);
								return (
									<ImageItem artwork={artwork} lazy={index >= eagerCount} />
								);
							})}
						</div>
					))}
				</div>
			</template>
		);
	})
}

<style>
	.static-masonry-grid {
		width: 100%;
		display: flex;
		margin-left: -1rem;
	}

	.static-masonry-column {
		flex: 1;
		display: flex;
		flex-direction: column;
		gap: 1rem;
		padding-left: 1rem;
	}
</style>

<script define:vars={{ breakpointCols }}>
	let imageObserver = null;

	function initLazyLoading() {
		if (imageObserver) {
			imageObserver.disconnect();
		}

		imageObserver = new IntersectionObserver(
			(entries, observer) => {
				entries.forEach((entry) => {
					if (entry.isIntersecting) {
						const img = entry.target;
						const src = img.getAttribute('data-src');
						const srcset = img.getAttribute('data-srcset');
						const sizes = img.getAttribute('data-sizes');

						if (src) {
							img.src = src;
							if (srcset) img.srcset = srcset;
							if (sizes) img.sizes = sizes;

							img.onload = () => {
								// Remove skeleton and min-height constraint
								const skeleton = img.previousElementSibling;
								if (skeleton) skeleton.remove();

								const wrapper = img.parentElement;
								if (wrapper && wrapper.classList.contains('min-h-[300px]')) {
									wrapper.classList.remove('min-h-[300px]');
								}

								img.classList.remove('opacity-0');
								img.classList.add('opacity-100');
							};

							observer.unobserve(img);
						}
					}
				});
			},
			{
				rootMargin: '200px 0px',
				threshold: 0.01,
			},
		);

		// Observe all lazy images
		document.querySelectorAll('.lazy-image').forEach((img) => {
			imageObserver.observe(img);
		});
	}

	function getLayoutForViewport() {
		const width = window.innerWidth;

		const breakpoints = Object.keys(breakpointCols)
			.filter((key) => key !== 'default' && !isNaN(Number(key)))
			.map(Number)
			.sort((a, b) => a - b);

		for (const breakpoint of breakpoints) {
			if (width <= breakpoint) {
				return breakpointCols[breakpoint];
			}
		}

		return breakpointCols.default || breakpointCols[Math.max(...breakpoints)];
	}

	function renderLayout() {
		const columnCount = getLayoutForViewport();
		const template = document.querySelector(
			`template[data-layout="${columnCount}"]`,
		);
		const container = document.getElementById('masonry-container');

		if (!template || !container) return;

		container.innerHTML = '';

		const content = template.content.cloneNode(true);
		container.appendChild(content);

		initLazyLoading();
	}

	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', renderLayout);
	} else {
		renderLayout();
	}

	let resizeTimeout;
	window.addEventListener('resize', () => {
		clearTimeout(resizeTimeout);
		resizeTimeout = setTimeout(renderLayout, 200);
	});
</script>
